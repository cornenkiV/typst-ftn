= Дизајн и имплементација P2P мреже

Након детаљног објашњења како консензус алгоритми раде самостално, у овом поглављу ће се објаснити како се они уклапају у реалну _P2P_ мрежу, која има више чворова који комуницирају међусобно. Да би блокчејн систем био заиста децентрализован, неопходно је успоставити механизме који омогућавају независним чворовима (енг. _nodes_) да се међусобно проналазе, комуницирају, синхронизују податке и заједнички учествују у постизању консензуса.

== Архитектура мреже

Да би се омогућила флексибилност и лака замена мрежних топологија, целокупна мрежна логика је апстрахована кроз `NetworkLayer` који дефинише основни уговор који свака мрежна имплементација мора да испуни.

#figure(
  caption: [
    `NetworkLayer` у Rust-у.
  ],
  ```rust
  pub trait NetworkLayer: Send + Sync {
      fn broadcast(&self, message: &P2PMessage) -> Result<(), NetworkError>;
      fn send_to(&self, node_id: &str, message: &P2PMessage) -> Result<(), NetworkError>;
      fn get_connected_peers(&self) -> Vec<String>;
  }
  ```
)

Овај приступ омогућава да се у раду истраже и имплементирају два фундаментално различита модела мрежне топологије: централизована звезда (_Star_) топологија и децентрализована мрежа (_Mesh_) топологија.

=== Звезда (енг. _Star_) топологија

Звезда топологија представља једноставнији, централизовани приступ. У овој архитектури, један чвор, назван `BootstrapNode`, има улогу централног сервера. Сви остали чворови у мрежи, `RegularNode`, успостављају директну и једину конекцију са овим централним чвором.

Комуникација се одвија на следећи начин:
1.  `RegularNode` (клијент) шаље поруку ка `BootstrapNode` (серверу).
2.  `BootstrapNode` прима поруку, обрађује је и прослеђује је свим осталим повезаним клијентима користећи своју `broadcast` методу.

Овај модел је имплементиран кроз две структуре:
- `StarNetworkServer`: Користи се од стране `BootstrapNode` чвора за ослушкивање долазећих конекција и управљање листом повезаних клијената.
- `StarNetworkClient`: Користи се од стране `RegularNode` чворова за успостављање и одржавање конекције са централним сервером.

Главна предност ове топологије је једноставност имплементације и управљања мрежом. Идеја је била да се покаже конкурентност у процесу рударења између више чворова и постизање консензуса. Али ова топологија има ману, она уводи централну тачку отказа (енг. _single point of failure_). Уколико `BootstrapNode` престане са радом, целокупна мрежа постаје нефункционална.

=== Мрежа (енг. mesh) топологија

Као потпуно децентрализована алтернатива, имплементирана је и мрежа топологија. У овом моделу не постоји централни сервер. Сваки чвор (`MeshNode`) директно се повезује са више других чворова у мрежи, формирајући децентрализовану мрежасту структуру.

Улога `BootstrapNode` чвора је у овом случају сведена на сервис за откривање (енг. _discovery service_):
1.  Нови `MeshNode` се приликом покретања привремено повезује са `BootstrapNode` чвором.
2.  `BootstrapNode` му шаље листу адреса осталих активних `MeshNode` чворова у мрежи.
3.  Након добијања листе, нови чвор прекида везу са `BootstrapNode`-ом и започиње процес директног повезивања са другим чворовима са добијене листе.

Да би се избегла фрагментација мреже, где би се могла формирати изолована острва чворова, поставља се питање колико је конекција потребно успоставити да би мрежа са великом вероватноћом остала повезана. Одговор на ово питање даје теорија случајних графова Ердеш-Рењи модел (енг. _Erdos–Renyi model_) @erdosrenyi. Према овом моделу, тачка у којој граф са `n` чворова са високом вероватноћом прелази из неповезаног у повезан, дешава се када је просечан број конекција по чвору приближно једнак `ln(n)`. За очекивану величину мреже од око 20 чворова, `ln(20) ≈ 2.99`. Под том претпоставком, у овој имплементацији је изабрано да сваки нови чвор успостави три одлазне конекције, што представља практичну примену овог теоријског принципа како би се осигурала повезаност мреже.

Комуникација се одвија директно од чвора до чвора. Када један чвор жели да пошаље поруку целој мрежи, он је шаље само својим директно повезаним суседима. Ти суседи затим прослеђују поруку својим суседима, и тако даље, док се порука не прошири кроз целу мрежу. Овај механизам пропагације се назива _Gossip_ протокол. Ова топологија је знатно отпорнија на отказе, али је комплекснија за имплементацију због потребе за управљањем већим бројем конекција и спречавањем бесконачног кружења порука.

== Мрежни протокол

Да би чворови у _P2P_ мрежи могли међусобно да комуницирају на структуриран начин, неопходно је дефинисати јасан комуникациони протокол. У овој имплементацији, протокол је реализован преко _TCP/IP_ сокета, где се све поруке серијализују у _JSON_ формат пре слања.

Протокол је дефинисан са `P2PMessage` енумерацијом (енг. _enum_) која дефинише све типове порука које чворови могу размењивати.

#figure(
  caption: [
    `P2PMessage` енумерација која дефинише комуникациони протокол
  ],
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub enum P2PMessage {
      Join { node_id: String, address: String, timestamp: u64 },
      PeerList { peers: Vec<PeerInfo> },
      Heartbeat { node_id: String, timestamp: u64 },
      Pong { node_id: String },
      Disconnect { node_id: String },
      Rejected { reason: String },

      RequestBlockchain { requester_id: String },
      BlockchainSync { chain: Vec<Block> },
      
      MiningStart { template: BlockTemplate },
      MiningStop,
      NewBlock { block: Block, miner_id: String },

      NewTransaction { transaction: String, from_node: String },
  }
  ```
)

Значење и сврха кључних типова порука су следећи:

 -   *Управљање конекцијама:*
    -   `Join`: Прва порука коју нови чвор шаље `BootstrapNode` чвору како би затражио улазак у мрежу
    -   `PeerList`: Порука којом `BootstrapNode` одговара на `Join` у kojoj шаљe новом чвору листу адреса осталих активних чворова
    -   `Heartbeat` и `Pong`: Механизам за одржавање конекције
    -   `Disconnect`: Порука којом чвор обавештава мрежу да се искључује
    -   `Rejected`: Порука којом чвор одбија долазећу конекцију, на пример због достигнутог максималног броја конекција

 -   *Синхронизација и консензус:*
    -   `RequestBlockchain`: Порука којом чвор тражи од другог чвора да му пошаље своју комплетну копију блокчејна
    -   `BlockchainSync`: Одговор на `RequestBlockchain` који садржи комплетан низ блокова (`Vec<Block>`)

-   *Координација рударења:*
    -   `MiningStart`: Порука којом се иницира рударење. Порука садржи `BlockTemplate` структуру која дефинише све потребне податке за креирање новог блока
    -   `MiningStop`: Сигнал који се шаље свим чворовима да прекину рударење
    -   `NewBlock`: Порука којом рудар који је пронашао блок емитује (енг. _broadcast_) нови блок остатку мреже

-   *Трансакције:*
    -   `NewTransaction`: Порука којом се нова трансакција додаје како би била укључена у наредни блок


== Мрежни процеси

Функционисање _P2P_ мреже се заснива на неколико кључних процеса који омогућавају чворовима да се придруже, одржавају усаглашеност и заједнички доприносе расту блокчејна. У овом раду, два најважнија процеса су синхронизација новог чвора са мрежом и циклус дистрибуираног рударења.

=== Прикључивање и синхронизација новог чвора

Када се нови чвор покрене, он не поседује никакве информације о тренутном стању мреже. Први корак је да се повеже са мрежом и синхронизује. Овај процес се одвија кроз следеће кораке:

1.  *Проналажење улазне тачке:* Нови чвор се прво повезује са унапред познатом адресом _`BootstrapNode`_ чвора, који служи као почетна тачка за улазак у мрежу.

2.  *Захтев за информацијама:* Чвор шаље _`Join`_ поруку како би се представио, а затим и _`RequestBlockchain`_ поруку како би затражио актуелну верзију блокчејна.

3.  *Пријем и обрада података:*
    -   У звезда топологији, _`BootstrapNode`_ директно одговара _`BlockchainSync`_ поруком која садржи цео ланац.
    -   У мрежа топологији, _`BootstrapNode`_ одговара _`PeerList`_ поруком. Нови чвор затим прекида везу са _bootstrap_ чвором, повезује се са чворовима са листе и од њих тражи синхронизацију блокчејна.

4.  *Валидација и усвајање ланца:* По пријему, нови чвор извршава валидацију примљеног ланца позивањем функције _`Blockchain::validate_chain`_. Ова функција проверава повезаност, исправност хешева и поштовање PoW правила за сваки блок. Уколико је ланац валидан, чвор га усваја као своју локалну копију.

=== Циклус дистрибуираног рударења

Процес креирања новог блока је дистрибуиран и конкурентан, одвија се кроз следеће кораке:

1.  *Иницирање рударења:* Рударење започиње када један од чворова одлучи да је време за креирање новог блока (на пример када се у `mempool`-у накупи довољан број трансакција). Тај чвор креира _`BlockTemplate`_  и емитује _`MiningStart`_ поруку осталим чворовима у мрежи.
    -   У звезда топологији, ову улогу увек има _`BootstrapNode`_.
    -   У мрежа топологији, било који чвор може иницирати рударење.

2.  *Паралелно рударење:* По пријему _`MiningStart`_ поруке, сваки чвор покреће рударење. Сви чворови у мрежи се сада истовремено такмиче ко ће први пронаћи валидан блок.

3.  *Проналазак решења и емитовање блока:* Чвор који први пронађе валидан нонс формира комплетан блок. Он прекида рударење и емитује _`NewBlock`_ поруку остатку мреже.

4.  *Пропагација и прекид рада:* Остали чворови примају _`NewBlock`_ поруку. Након што валидирају блок додају га у свој ланац и прекидају процес рударења. Ово рано заустављање осигурава да се рачунарски ресурси не троше узалуд након што је решење већ пронађено.

Овај координисани процес осигурава да се рачунарски ресурси целе мреже ефикасно користе за рударење, уз механизам који спречава непотребан рад након што је решење већ пронађено.

== Постизање консензуса: правило најдужег ланца

У дистрибуираној мрежи може се догодити да два или више рудара пронађу решење за исти блок у приближно исто време. Када се то деси, оба чвора ће емитовати своје валидне блокове у мрежу. Чворови који су у мрежи ближи првом рудару ће прво примити његов блок, док ће други део мреже прво примити блок другог рудара. Ова ситуација доводи до привременог рачвања ланца, познатог као форк (енг. _fork_), где у мрежи истовремено постоје две различите, али валидне верзије блокчејна.

Да би се овакви конфликти разрешили и мрежа усагласила око једне верзије ланца, блокчејн системи засновани на _Proof-of-Work_ алгоритму углавном користе једноставно правило најдужег ланца (енг. _longest chain rule_). Ово правило каже да се верзија блокчејна која је најдужа сматра валидном.

Овај механизам је имплементиран кроз логику за обраду долазећих _`NewBlock`_ и _`BlockchainSync`_ порука унутар _`handle_message_static`_ функција у _`RegularNode`_ и _`MeshNode`_ структурама. Процес се одвија на следећи начин:

1.  *Пријем новог блока или ланца:* Када чвор прими нови блок путем _`NewBlock`_ поруке, он прво извршава валидацију. Уколико прими цео ланац путем _`BlockchainSync`_ поруке, валидира се цео примљени ланац.

2.  *Валидација:* Процес валидације проверава неколико услова:
    -   Да ли се хеш блока поклапа са његовим садржајем.
    -   Да ли _`previous_hash`_ у новом блоку одговара хешу последњег блока у тренутном локалном ланцу.
    -   Да ли хеш блока задовољава задату тежину.

3.  *Одлучивање:*
    -   Ако је примљени блок валидан и директно се надовезује на врх тренутног ланца, чвор га додаје на крај.
    -   Ако примљени блок није валидан или се не надовезује на тренутни ланац (што указује на форк), чвор игнорише тај блок и покреће процес синхронизације. Он шаље _`RequestBlockchain`_ поруку другим чворовима како би добио њихове верзије ланца.
    -   Када чвор прими цео ланац, он прво проверава његову дужину. Ако је примљени ланац дужи од његовог тренутног, чвор покреће процес реорганизације.

4.  *Реорганизација ланца:* Процес реорганизације, имплементиран у функцији _`Blockchain::reorganize`_, једноставно замењује тренутни локални ланац са новим, дужим ланцем.

== _Gossip_ протокол и пропагација порука

У децентрализованој мрежа топологији неопходно је имати ефикасан механизам за ширење информација кроз целу мрежу. У овом раду је за ту сврху имплементиран _Gossip_ протокол. Основна идеја је да када чвор прими нову поруку коју није видео раније, он је прослеђује свим својим повезаним суседима. Ти суседи затим понављају исти процес, што доводи до ширења поруке кроз мрежу.

Овај механизам је имплементиран у функцији _`MeshNetwork::gossip_broadcast`_. Овакав приступ уводи два потенцијална проблема:
1.  *Дуплирање порука:* Чвор може примити исту поруку више пута од различитих суседа.
2.  *Бесконачне петље:* Порука може бесконачно кружити кроз мрежу ако не постоји механизам за заустављање.

Да би се ови проблеми решили, имплементиран је механизам за праћење виђених порука, чија се логика налази у структури _`MessageTracker`_ и функцији _`compute_message_id`_.

=== Механизам за спречавање дупликата

У овом протоколу спречавање дуплираних порука реализовано је кроз следеће кораке:

1.  *Генерисање идентификатора поруке:* За сваку поруку која се шаље кроз мрежу, генерише се јединствени идентификатор.

#figure(
  caption: [
    Функција за генерисање ID поруке.
  ],
  ```rust
  pub fn compute_message_id(message: &P2PMessage) -> String {
      let serialized = serde_json::to_string(message).unwrap_or_default();
  
      let mut hasher = Sha256::new();
      hasher.update(serialized.as_bytes());
      let hash = hasher.finalize();
  
      format!("{:x}", hash)[..16].to_string()
  }
  ```
)

2.  *Праћење виђених порука:* Сваки _`MeshNode`_ поседује инстанцу _`MessageTracker`_ структуре, која у себи садржи хеш мапу (_`HashMap<String, Instant>`_). Ова мапа чува идентификаторе свих порука које је чвор видео, заједно са временском ознаком када их је видео.

3.  *Процес обраде и прослеђивања:* Када _`MeshNode`_ прими поруку он прво израчунава њен идентификатор и проверава да ли се тај идентификатор већ налази у његовом _`MessageTracker`_-у.
    -   Ако је идентификатор већ забележен, чвор игнорише поруку и прекида даљу обраду.
    -   Ако идентификатор није забележен, чвор га уписује у _`MessageTracker`_, обрађује поруку и прослеђује је свим својим суседима.

Овај механизам ефикасно спречава да се иста порука обрађује више пута и зауставља њено бесконачно кружење.
= Имплементација консензус алгоритама

У овом поглављу детаљно ће бити приказана техничка реализација кључних компоненти блокчејн система. Фокус је на имплементацији _Proof-of-Work_ и _Proof-of-Stake_ консензус алгоритама. За потребе анализе резултата, _Proof-of-Work_ алгоритам је имплементиран у програмским језицима _Python_ и _Rust_, док је за енергетски ефикаснији _Proof-of-Stake_ алгоритам коришћен _Rust_ због његових напредних могућности за сигуран рад са више нити.

== Заједничке структуре података

У основи сваког блокчејн система налазе се две фундаменталне структуре података: `Block`, која представља појединачну карику, и `Blockchain`, која представља цео ланац. У овом пројекту, ове структуре су дефинисане у програмском језику _Rust_, са циљем да буду меморијски ефикасне и робусне.

Структура `Block` је дизајнирана да садржи све неопходне елементе за функционисање ланца.

#figure(
  caption: [
    Структура `Block` у _Rust_-у.
  ],
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Block {
      pub previous_hash: String,
      pub timestamp: i64,
      pub nonce: u64,
      pub data: String,
      pub hash: String,
  }
  ```
)

Кључна поља су:
- `previous_hash`: `String` који чува хеш претходног блока, чиме се остварује веза у ланцу
- `timestamp`: `i64` вредност која представља UNIX временску ознаку креирања блока
- `nonce`: oво поље је кључно за PoW алгоритам, јер се његова вредност мења у свакој итерацији рударења
- `data`: `String` који у овом раду садржи информације о трансакцијама унутар блока
- `hash`: `String` који чува `SHA-256` хеш блока, израчунат на основу свих осталих поља

Структура `Block` имплементира неколико важних метода. Метода `calculate_hash()` конкатенира све остале податке у блоку, претвара их у низ бајтова и на њих примењује SHA-256 хеш функцију. Ова метода је централна за процес рударења и валидације. Метода `meets_difficulty(difficulty: usize)` проверава да ли израчунати хеш задовољава тренутну тежину мреже, односно да ли почиње са одговарајућим бројем нула.

Друга основна структура, `Blockchain`, обједињује блокове у ланац.

#figure(
  caption: [
    Структура `Blockchain` у _Rust_-у.
  ],
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Blockchain {
      pub chain: Vec<Block>,
      pub difficulty: usize,
  }
  ```
)
Ова структура садржи два поља:
- `chain`: Вектор који чува низ свих блокова, почевши од генесис блока.
- `difficulty`: вредност која дефинише тежину рударења за цео ланац.

Приликом креирања новог `Blockchain` објекта, аутоматски се иницијализује и додаје генесис блок, који служи као почетна тачка ланца. Структура такође садржи методе за додавање новог блока (`add_block`), као и за валидацију интегритета целог ланца (`is_valid`), која проверава да ли сваки блок исправно референцира хеш претходног и да ли задовољава задату тежину. Ове структуре представљају основу на којој се граде сви алгоритми описани у наредним поглављима.


== _Proof-of-Work_: Секвенцијална имплементација

Секвенцијална имплементација _Proof-of-Work_ алгоритма представља најједноставнији приступ рударењу и служи као темељ за разумевање рачунарске захтевности овог процеса. У овом моделу, једна процесорска нит (енг. _thread_) извршава целокупан посао, тестирајући нонс вредности једну по једну, редом, док не пронађе решење.

Ова имплементација је од кључног значаја за експерименталну анализу, јер време извршавања на једном језгру ($T_1$) представља основну референтну вредност за израчунавање убрзања и ефикасности паралелних верзија. Логика је идентична у оба програмска језика, започиње се са нонс вредношћу 0, у свакој итерацији се креира нови блок, рачуна његов SHA-256 хеш и проверава да ли задовољава задату тежину. Уколико не, нонс се инкрементира за 1 и процес се понавља.

=== Имплементација у програмском језику _Python_

У програмском језику _Python_, секвенцијално рударењe је реализованo унутар функције `mine_block`. Ова функција садржи "_brute-force_" петљу која итеративно проверава нонс вредности.

#figure(
  caption: [
    Секвенцијална функција за рударење у _Python_-у.
  ],
  ```python
    def mine_block(
        previous_hash: str,
        transactions: List[Transaction],
        difficulty: int,
        start_nonce: int = 0,
        max_nonce: int = None,
        progress_callback=None,
    ) -> tuple[Block, int]:
        required_prefix = "0" * difficulty
        nonce = start_nonce
        nonces_tested = 0
        timestamp = time.time()

        while max_nonce is None or nonce < max_nonce:
            block = Block(previous_hash, transactions, timestamp, nonce)
            nonces_tested += 1

            if progress_callback and nonces_tested % 100000 == 0:
                progress_callback(nonce, block.hash)

            if block.hash.startswith(required_prefix):
                return block, nonces_tested

            nonce += 1

        return None, nonces_tested
  ```
)

Анализа функције `mine_block`:
1. На почетку се дефинише `required_prefix` који представља циљни услов који хеш мора да задовољи
2. `while` петља се извршава бесконачно док се не пронађе решење
3. У свакој итерацији креира се нова инстанца класе `Block` са тренутном `nonce` вредношћу. Хеш се аутоматски рачуна приликом иницијализације објекта користећи `hashlib` библиотеку
4. Проверава се да ли израчунати хеш почиње са захтеваним префиксом (`block.hash.startswith(required_prefix)`)
5. Ако је услов испуњен, функција враћа пронађени блок и укупан број тестираних `nonce` вредности
6. У супротном, `nonce` се инкрементира за 1 и процес се наставља

Овај приступ, иако функционалан, ограничен је перформансама самог _Python_ интерпретера. Као интерпретирани језик, _Python_ извршава код линију по линију, што је значајно спорије од компајлираних језика за рачунарски интензивне задатке као што је хеширање.

=== Имплементација у програмском језику _Rust_

Имплементација у _Rust_-у прати исту "_brute-force_" логику, али са значајним предностима у перформансама јер је _Rust_ компајлирани језик који генерише оптимизован машински код. Централна логика је у функцију `mine_block`.

#figure(
  caption: [
    Секвенцијална функција за рударење у _Rust_-у.
  ],
  ```rust
  fn mine_block(
      previous_hash: String,
      timestamp: i64,
      data: String,
      difficulty: usize,
  ) -> (Block, u64) {
      let mut nonce = 0u64;
      let mut attempts = 0u64;
  
      loop {
          let block = Block::new(previous_hash.clone(), timestamp, nonce, data.clone());
          attempts += 1;
  
          if block.meets_difficulty(difficulty) {
              return (block, attempts);
          }
  
          nonce += 1;
      }
  }
  ```
)

Функција користи бесконачну `loop` петљу. У свакој итерацији:
1. Иницијализује се нова инстанца `Block` структуре са тренутном `nonce` вредношћу
2. Бројач покушаја (`attempts`) се инкрементира
3. Позива се метода `meets_difficulty()` над блоком како би се проверило да ли његов хеш задовољава услов
4. Ако је услов испуњен, петља се прекида и функција враћа пронађени блок заједно са укупним бројем покушаја
5. Ако услов није испуњен, `nonce` се инкрементира за 1 и петља наставља са следећом итерацијом

Ова имплементација је директна, меморијски ефикасна и представља чисту демонстрацију рачунарског рада који је потребно уложити да би се пронашло решење у _Proof-of-Work_ систему. Њене перформансе ће послужити као референтна тачка за мерење ефикасности паралелне верзије у _Rust_-у.
Извршавање ове имплементације чини основу за процену ефикасности паралелне имплементације.


== _Proof-of-Work_: Паралелна имплементација

Прелазак са секвенцијалног на паралелни модел извршавања је кључан корак ка постизању високих перформанси у _Proof-of-Work_ рударењу. С обзиром на то да је процес провере сваке нонс вредности потпуно независан од осталих, проблем је инхерентно паралелизабилан. Основни циљ је расподелити целокупан простор нонс вредности на више радника (енг. _workers_) како би се претрага одвијала истовремено на свим доступним процесорским језгрима.

Иако је циљ исти, приступ паралелизацији се суштински разликује у програмским језицима _Python_ и _Rust_, пре свега због њихових фундаменталних разлика у управљању конкурентним извршавањем.

=== Имплементација у програмском језику _Python_

Због ограничења које намеће Глобални интерпретерски катанац (енг. Global Interpreter Lock, GIL), стандардне нити у _Python_-у не могу истовремено извршавати CPU-интензиван код. Стога је за праву паралелизацију неопходно користити модул `multiprocessing`, који заобилази GIL тако што креира засебне процесе уместо нити. Сваки процес добија сопствени _Python_ интерпретер и меморијски простор. Иако је овај приступ ефикасан за паралелизацију, он уводи додатно оптерећење у виду сложеније комуникације и синхронизације између процеса.

У овој имплементацији, креиран је скуп радничких процеса (енг. _Pool_) којима се додељује посао. Срж логике сваког радника налази се у функцији `worker_mine`

#figure(
  caption: [
    Функција `worker_mine` за паралелно рударење у _Python_-у
  ],
  ```python
  def worker_mine(
      worker_id, previous_hash, transactions_data, timestamp,
      difficulty, start_nonce, step, found_flag, result_queue
  ):
      # ... (inicijalizacija)
      nonce = start_nonce

      while True:
        block = Block(previous_hash, transactions, timestamp, nonce)
        nonces_tested += 1
        if block.hash.startswith(required_prefix):
            found_flag.value = 1
            result = { "found": True, "block_data": ..., "nonce": nonce, ... }
            result_queue.put(result)
            return result
        
        if nonces_tested % check_interval == 0:
          if found_flag.value == 1:
              result = {
                  "worker_id": worker_id,
                  "found": False,
                  "nonces_tested": nonces_tested,
              }
              result_queue.put(result)

              return result
        nonce += step
  ```
)

Кључни аспекти ове имплементације су:
 -   *Подела посла:* Простор нонс вредности је подељен тако да сваки радник обрађује само део. Главни процес додељује сваком раднику јединствену почетну нонс вредност (`start_nonce = worker_id`), а сваки радник затим инкрементира свој нонс за укупан број радника (`step = num_workers`).  Овим се гарантује да неће доћи до преклапања и дуплог рада.

 -   *Синхронизација и прекид рада:* Да би се избегао непотребан рад након што један од радника пронађе решење, користе се два механизма из `multiprocessing` модула:
    -   `found_flag = manager.Value("i", 0)`: Дељена променљива која служи као заставица. Када радник пронађе решење, поставља вредност ове заставице на 1.
    -   `result_queue = manager.Queue()`: Дељени ред у који радници смештају своје резултате.
    Сваки радник периодично проверава вредност `found_flag`. Уколико примети да је вредност 1, прекида свој рад и завршава извршавање. Овај механизам обезбеђује "рано заустављање" (енг. _early termination_).

=== Имплементација у програмском језику Rust

_Rust_ омогућава знатно ефикаснију паралелизацију захваљујући свом моделу власништва који гарантује сигурност при раду са меморијом без потребе за "garbage collector"-ом или GIL-ом. У овом пројекту коришћена је библиотека _`Rayon`_. Имплементира _"work-stealing"_ распоређивач који омогућава веома ефикасну расподелу посла међу нитима уз минимално оптерећење.

Целокупна паралелна логика је смештена унутар функције `mine_block_parallel`, где се користи _`Rayon`_ креатор скупа нити (енг. _`ThreadPoolBuilder`_) 

#figure(
  caption: [
    Паралелна петља за рударење у _Rust_-у коришћењем библиотеке _`Rayon`_
  ],
  ```rust
    rayon::ThreadPoolBuilder::new()
      .num_threads(num_workers)
      .build()
      .unwrap()
      .install(|| {
        (0..num_workers).into_par_iter().for_each(|thread_id| {
            // ... (иницијализација)

            while !found.load(Ordering::Relaxed) {
                let block = Block::new(previous_hash.clone(), timestamp, nonce, data.clone());
                local_attempts += 1;
                if block.meets_difficulty(difficulty) {
                    if !found.swap(true, Ordering::SeqCst) {
                        let mining_result = MiningResult {
                            block,
                            attempts: local_attempts,
                            thread_id,
                        };
                        *result.lock() = Some(mining_result);
                    }
                    break;
                }

                nonce += num_workers as u64;
            }
            // чување података за анализу...
        });
    });
  ```
)


Кључни аспекти ове имплементације су:
 -   *Подела посла:* Примењена је идентична стратегија подели нонс простора као у _Python_ имплементацији. Свака нит, идентификована својим `thread_id`, добија јединствену почетну нонс вредност (`nonce = thread_id as u64`) и инкрементира је за укупан број радника (`nonce += num_workers as u64`). Ово омогућава директно и фер поређење ефикасности два приступа.

 -   *Синхронизација и прекид рада:* Уместо тежих механизама за комуникацију између процеса, _Rust_ користи атомске операције и мутексе за синхронизацију међу нитима:
    -   `found = Arc<AtomicBool::new(false)>`: Дељена атомска променљива која служи као заставица за заустављање. Атомске операције су изузетно брзе јер се извршавају као једна, непрекидна инструкција на нивоу хардвера. Свака нит у петљи проверава ову заставицу са `found.load(Ordering::Relaxed)`.
    -   `if !found.swap(true, Ordering::SeqCst)`: Ова линија представља кључни део механизма. `swap` је атомска _"test-and-set"_ операција која истовремено поставља вредност заставице на `true` и враћа њену претходну вредност. Само она нит која прва изврши ову операцију ће добити `false` као повратну вредност и ући у `if` блок како би сачувала резултат. Све остале нити које стигну касније ће видети да је вредност већ `true`, неће ући у блок и само ће прекинути свој рад.
    -   `result: Arc<parking_lot::Mutex<...>>`: Резултат се чува у меморијској локацији заштићеној мутексом, како би се гарантовао сигуран упис од стране победничке нити. `parking_lot` је алтернативна имплементација мутекса која има мањи меморијски _`overhead`_ и боље перформансе.


== Имплементација _Proof-of-Stake_ симулације

За разлику од рачунарски интензивног _Proof-of-Work_ алгоритма, _Proof-of-Stake_ се фокусира на економски подстицај и процес валидације. Имплементација у овом раду представља симулацију PoS консензуса у _Rust_-у, дизајнирану да демонстрира кључне механизме и измери перформансе система. Цео процес се може поделити на два главна корака, избор валидатора који предлаже блок, и паралелна валидација тог блока од стране свих учесника у мрежи.

=== Избор предлагача блока

Први корак у свакој рунди креирања блока је одређивање који валидатор има право да га предложи. Уместо такмичења, овај процес је заснован на алгоритму пондерисаног случајног избора @weightedrandom (енг. _weighted random selection_), где је тежина сваког валидатора одређена величином његовог улога (`stake`). Ова логика је имплементирана у функцији `select_validator_weighted`.

#figure(
  caption: [
    Функција за пондерисани избор валидатора у _Rust_-у.
  ],
  ```rust
  pub fn select_validator_weighted(validators: &[Validator]) -> &Validator {
      let mut rng = rand::thread_rng();
      let total_stake: u64 = validators.iter().map(|v| v.stake).sum();
      let mut random_stake = rng.gen_range(0..total_stake);
  
      for validator in validators {
          if random_stake < validator.stake {
              return validator;
          }
          random_stake -= validator.stake;
      }
  
      &validators[0]
  }
  ```
)

Функција прво израчунава укупан улог свих валидатора у мрежи. Затим генерише случајан број у опсегу од 0 до укупног улога. Након тога, пролази кроз листу валидатора и од сваког редом одузима његов улог од генерисаног броја. Први валидатор код којег је преостала вредност случајног броја мања од његовог улога бива изабран. Овај алгоритам осигурава да валидатори са већим улогом имају пропорционално већу шансу да буду изабрани, што је кључно за PoS систем.

=== Паралелна валидација блока

Након што је случајним избором један валидатор одређен као предлагач за наредни блок, систем улази у фазу потврде. Иако је само један валидатор аутор блока, ова симулација користи прилику да демонстрира и тестира способност _Rust_-овог модела паралелизације да ефикасно реши проблем трке (енг. _race condition_). У том циљу, симулира се сценарио где сви валидатори истовремено добијају скуп трансакција за нови блок и параеллно почињу да их валидирају. Први валидатор који успешно заврши проверу свих трансакција побеђује у трци, након чега се блок сматра потврђеним и додаје у ланац.

Процес валидације је рачунарски захтеван. У методи `Transaction::validate()`, симулира се криптографски рад (као што је провера дигиталног потписа) извршавањем великог броја SHA-256 хеш итерација за сваку трансакцију. Ово омогућава да се измери утицај паралелизације на укупно време валидације.

Паралелна валидација је реализована коришћењем _`Rayon`_ библиотеке, слично као у PoW имплементацији. Главна петља у функцији `run_pos_consensus` покреће паралелну итерацију над свим валидаторима, позивајући функцију `validate_block_parallel` за сваког од њих.

#figure(
  caption: [
    Паралелна валидација блока у PoS симулацији.
  ],
  ```rust
    fn validate_block_parallel(
      transactions: &[Transaction],
      validator_id: u32,
      block_ready: Arc<AtomicBool>,
    ) -> (f64, u32, bool) {
      let start = Instant::now();

      if block_ready.load(Ordering::Relaxed) {
          return (start.elapsed().as_secs_f64() * 1000.0, validator_id, false);
      }

      let all_valid = transactions.iter().all(|tx| {
          if block_ready.load(Ordering::Relaxed) {
              return false;
          }
          tx.validate()
      });

      let elapsed_ms = start.elapsed().as_secs_f64() * 1000.0;

      if all_valid && !block_ready.swap(true, Ordering::SeqCst) {
          return (elapsed_ms, validator_id, true);
      }

      (elapsed_ms, validator_id, false)
  }
  ```
)

Слично као у паралелној PoW имплементацији, за синхронизацију се користи атомска заставица `block_ready: Arc<AtomicBool>`.
 -   Сваки валидатор (нит) прво проверава да ли је блок већ спреман (`block_ready.load`). Ако јесте, одмах прекида рад.
 -   Унутар `transactions.iter().all()`, који проверава да ли су све трансакције валидне, такође се проверава заставица како би се процес прекинуо што је раније могуће.
 -   Први валидатор који успешно заврши валидацију свих трансакција користи атомску `swap` операцију (`!block_ready.swap(true, Ordering::SeqCst)`). Само тај валидатор ће проћи ову проверу и вратити резултат `success: true`. Сви остали ће видети да је заставица већ постављена и завршиће свој рад без проглашења успеха.

Овакав "racing" модел ефикасно користи све доступне процесорске ресурсе за убрзавање процеса валидације, што резултира знатно краћим временом креирања блока у поређењу са PoW системом. Уместо нонс, у `Block` структуру се уписује `id` валидатора који је предложио блок.

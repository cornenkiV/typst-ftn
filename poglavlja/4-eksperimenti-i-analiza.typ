= Експерименти и анализа резултата

Ово поглавље представља експерименталну валидацију и анализу перформанси имплементација _Proof-of-Work_ алгоритма. Циљ је измерити утицај паралелизације на брзину извршавања и проценити скалабилност система у различитим условима. Кроз тестове јаког и слабог скалирања врши се анализа резултата имплементација у програмским језицима _Python_ и _Rust_.

Резултати представљени у овом поглављу имају за циљ да покажу практичне предности паралелног приступа. Анализа ће истаћи кључне разлике у перформансама између самих програмских језика и њихових модела за конкурентно извршавање.

== Спецификација система и методологија

Да би се обезбедила поновљивост и валидност добијених резултата, сви експерименти су спроведени у идентичном окружењу.

*Конфигурација система*

Сва мерења су извршена на рачунару са следећим хардверским и софтверским спецификацијама:
- *Процесор:* AMD Ryzen 5 5600X (6 језгара, 12 логичких процесора, 3.70GHz)
- *Кеш меморија:* L1-384KB, L2-3.0MB, L3-32.0MB
- *RAM меморија:* 16GB DDR4 на 3200MHz
- *Оперативни систем:* Windows 10
- *Python верзија:* 3.10.5
- *Rust (Cargo) верзија:* 1.87.0 (99624be96 2025-05-06)
- *Кључне библиотеке:* Rayon = "1.10", Python `multiprocessing`

*Методологија тестирања*

Експериментална анализа је усмерена искључиво на _Proof-of-Work_ алгоритам, с обзиром на то да је његов _"brute-force"_ приступ рачунарски најзахтевнији и најпогоднији за мерење убрзања. Тестирање је подељено у два главна експеримента:

- *Експеримент јаког скалирања:* Циљ је био измерити како се време извршавања смањује са повећањем броја процесорских ресурса за проблем фиксне величине. Величина проблема је била фиксирана на тежину рударења `d=5`, док је број радника варирао у корацима: 1, 2, 4, 8 и 12.

- *Експеримент слабог скалирања:* Циљ је био тестирати способност система да обради већи проблем са повећањем броја ресурса, уз очекивање да време извршавања остане приближно константно. Идеалан начин за скалирање проблема у PoW систему био би пропорционално повећање тежине (`difficulty`). Међутим, због експоненцијалне природе овог параметра, где повећање тежине за 1 повећава обим посла 16 пута, такав експеримент би захтевао значајно већи број процесорских језгара него што је било доступно. Примењен је алтернативни приступ где се величина проблема скалира линеарно повећањем броја блокова који се рударе. Величина проблема је расла пропорционално броју радника:
    - *Основни случај:* 1 радник рудари 5 блокова.
    - *Скалирани случајеви:* 2 радника рударе 10 блокова, 4 радника рударе 20 блокова, итд., одржавајући константан обим посла по раднику (5 блокова).

Ради постизања статистичке поузданости, свака конфигурација у оба експеримента је покренута 30 пута. У анализи су коришћене средње вредности времена извршавања, на основу којих су израчунате метрике убрзања и ефикасности.


== Експеримент јаког скалирања

У експерименту јаког скалирања, величина проблема је остала фиксна док се број доступних процесорских ресурса повећавао. Циљ овог теста био је да се измери како се време извршавања смањује и да се израчуна постигнуто убрзање (_Speedup_). За овај експеримент, тежина проблема је била фиксирана на `d=5`, док је број радника вариран кроз вредности 1, 2, 4, 8 и 12. Свака конфигурација је извршена 30 пута како би се обезбедила статистичка поузданост резултата.

Добијени резултати су упоређени са теоријским моделом Амдаловог закона. На основу експерименталних података, процењено је да серијски део програма, који обухвата операције попут припреме блока и синхронизације, чини приближно 2% укупног времена извршавања ($s = 0.02$).

=== Резултати за _Rust_ имплементацију

_Rust_ имплементација је показала одличне карактеристике јаког скалирања. Резултати мерења су приказани у табели @tbl:result-strong.

#figure(
  table(
    columns: 4,
    [ *Радници (p)*], [*Средње време (s)*], [*Стандардна девијација*], [*Убрзање*],
    [ 1 ], [ 28.08 ], [ 6.47 ], [ 1.00x ],
    [ 2 ], [ 15.47 ], [ 3.24 ], [ 1.81x ],
    [ 4 ], [ 8.04 ], [ 1.81 ], [ 3.49x ],
    [ 8 ], [ 4.42 ], [ 1.15 ], [ 6.35x ],
    [ 12 ], [ 3.75 ], [ 0.89 ], [ 7.49x ],
  ),
  caption: [Резултати јаког скалирања за _Rust_ имплементацију (тежина d=5).]
)<tbl:result-strong>

Анализа резултата показује да се експериментално добијено убрзање веома добро поклапа са идеалним линеарним убрзањем све до 4 радника. Ово указује на веома ниско додатно оптерећење (енг. _overhead_) паралелизације и ефикасно коришћење доступних процесорских језгара које омогућава _`Rayon`_ библиотека. Након 4 радника, убрзање почиње да одступа од идеалног, али и даље блиско прати теоријску криву дефинисану Амдаловим законом (слика @fig:result-strong). Пад ефикасности постаје израженији при преласку са 8 на 12 радника, што сугерише да се систем за дату величину проблема приближава тачки засићења, где трошкови синхронизације и комуникације између нити постају значајнији фактор.

#figure(
  image("../slike/jakoskaliranjerust.png", width: auto),
  caption: [Графички приказ јаког скалирања за _Rust_ имплементацију]
)<fig:result-strong>

=== Резултати за _Python_ имплементацију

_Python_ имплементација је такође постигла значајно убрзање, што потврђује да је проблем инхерентно паралелизован. Резултати мерења су приказани у табели @tbl:strong_python.

#figure(
  table(
    columns: 4,
    [*Радници (p)*], [*Средње време (s)*], [*Стандардна девијација*], [*Убрзање*],
    [ 1 ], [ 533.13 ], [ 102.10 ], [ 1.00x ],
    [ 2 ], [ 263.90 ], [ 51.49 ], [ 2.02x ],
    [ 4 ], [ 146.00 ], [ 38.06 ], [ 3.65x ],
    [ 8 ], [ 99.74 ], [ 19.48 ], [ 5.34x ],
    [ 12 ], [ 82.67 ], [ 15.34 ], [ 6.45x ],
  ),
  caption: [Резултати јаког скалирања за Python имплементацију (тежина d=5).]
)<tbl:strong_python>

Почетно скалирање са 2 и 4 радника је готово савршено. Убрзање од 2.02x са два радника је вероватно последица статистичке варијације, где је у 30 мерења просечно време било нешто боље од идеалног. Међутим, након 4 радника, пад ефикасности је знатно драстичнији у поређењу са _Rust_ имплементацијом  (слика @fig:strong_python). Главни узрок овоме је додатно оптерећење које уводи `multiprocessing` библиотека. За разлику од _Rust_-ових лаких нити, _Python_ креира знатно теже процесе. Комуникација између ових процеса захтева серијализацију и десеријализацију података (_pickling_), што је рачунарски скупа операција која постаје уско грло при већем броју радника.

#figure(
  image("../slike/jakoskaliranjepython.png", width: auto),
  caption: [Графички приказ јаког скалирања за _Python_ имплементацију]
)<fig:strong_python>

=== Упоредна анализа резултата

Директно поређење две имплементације открива неколико кључних разлика:

- *Апсолутне перформансе:* Најзначајнија разлика је у основној брзини извршавања. Секвенцијална _Rust_ имплементација (28.08s) је приближно 19 пута бржа од секвенцијалне _Python_ имплементације (533.13s). Ова разлика произилази из природе компајлираног језика који генерише оптимизован машински код, насупрот интерпретираном језику, као и _Rust_-ове контроле над меморијом на ниском нивоу.

- *Ефикасност скалирања:* Иако обе имплементације скалирају, _Rust_ то ради знатно ефикасније при већем броју језгара. Модел паралелизације у _Rust_-у, који користи дељену меморију и лаке нити, показује се супериорним за _CPU_-интензивне задатке у односу на _Python_-ов модел са више процеса и скупом серијализацијом података.

- *Утицај додатног оптерећења:* Резултати за _Python_ показују да оптерећење које уводе платформа и коришћене библиотеке може постати доминантан фактор који ограничава скалабилност. Код _Rust_ имплементације, ово оптерећење је знатно мање изражено.


== Експеримент слабог скалирања

У експерименту слабог скалирања, испитује се способност система да реши већи проблем са повећањем броја процесорских ресурса, уз очекивање да време извршавања остане приближно константно. Због експоненцијалне природе _PoW_ тежине, која би захтевала велики број језгара, примењен је алтернативни приступ где се величина проблема скалира повећањем укупног броја блокова који се рударе. Обим посла по раднику је одржаван константним, 5 блокова по раднику.

Резултати се анализирају кроз метрику скалираног убрзања, а упоређују се са теоријским моделом Густафсоновог закона.

=== Резултати за _Rust_ имплементацију

_Rust_ имплементација је показала добре карактеристике слабог скалирања, иако не савршене.

#figure(
  table(
    columns: 4,
    [ *Радници (p)*], [*Број блокова*], [*Средње време (s)*], [*Стандардна девијација (s)* ],
    [ 2 ], [ 10 ], [ 0.4862 ], [ 0.1215 ],
    [ 4 ], [ 20 ], [ 0.5163 ], [ 0.1033 ],
    [ 8 ], [ 40 ], [ 0.6357 ], [ 0.1057 ],
    [ 12 ], [ 60 ], [ 0.8218 ], [ 0.0849 ],
  ),
  caption: [Резултати слабог скалирања за _Rust_ имплементацију]
)

Резултати показују да време извршавања остаје релативно стабилно при мањем броју радника. Са повећањем броја радника на 8 и 12, приметан је пораст времена извршавања. Овај пораст указује на то да систем не скалира са савршеном ефикасношћу.

#figure(
  image("../slike/slabo_skaliranje_rust.png", width: auto),
  caption: [Графички приказ слабог скалирања за _Rust_ имплементацију]
)<fig:weak_rust>

График за слабо скалирање _Rust_ имплементације (слика @fig:weak_rust) јасно приказује ово понашање. Експериментална линија скалираног убрзања благо одступа од идеалне и теоријске линије, са падом ефикасности који постаје значајнији како се број нити повећава. Овај пораст времена извршавања може се повезати са додатном оптерећењу које настаје услед синхронизације и управљања већим бројем нити.

=== Резултати за _Python_ имплементацију

_Python_ имплементација показује знатно веће проблеме у слабом скалирању. Време извршавања не остаје константно већ расте са сваким повећањем броја радника и величине проблема.

#figure(
  table(
    columns: 4,
    [ *Радници (p)*], [*Број блокова*], [*Средње време (s)*], [*Стандардна девијација (s)*],
    [ 2 ], [ 10 ], [ 9.3645 ], [ 2.6114 ],
    [ 4 ], [ 20 ], [ 13.3507 ], [ 2.1815 ],
    [ 8 ], [ 40 ], [ 25.5783 ], [ 2.1543 ],
    [ 12 ], [ 60 ], [ 38.1508 ], [ 1.8488 ],
  ),
  caption: [Резултати слабог скалирања за _Python_ имплементацију]
)

Време потребно за рударење 60 блокова са 12 радника је преко четири пута дуже од времена потребног за рударење 10 блокова са 2 радника, што указује на веома лошу ефикасност слабог скалирања.

#figure(
  image("../slike/slabo_skaliranje_python.png", width: auto),
  caption: [Графички приказ слабог скалирања за _Python_ имплементацију]
)<fig:weak_python>

На графику за _Python_ (слика @fig:weak_python) се овај проблем јасно види. Експерментална линија скалираног убрзања стагнира већ након 2 радника, показујући огромно одступање од идеалног скалирања. Ово указује на то да систем не успева да ефикасно искористи додатне ресурсе за обраду већег проблема.

Главни узрок овако лошег скалирања је велико додатно оптерећење _Python_ _`multiprocessing`_ модула. Са повећањем броја радника и количине посла, ово оптерећење расте брже од користи која се добија паралелизацијом, што доводи до драстичног пада ефикасности. У директном поређењу, _Rust_ показује значајно супериорније карактеристике слабог скалирања. Ово потврђује да је његов модел са лаким нитима и дељеном меморијом далеко погоднији за овакав проблема.


== Поређење _Python_ и _Rust_

Резултати експеримената јаког и слабог скалирања омогућавају анализу перформанси _Proof-of-Work_ имплементација у програмским језицима _Python_ и _Rust_. Обе имплементације успешно користе паралелизацију за убрзавање процеса рударења, али разлике у њиховим основним карактеристикама и моделима за конкурентно извршавање доводе до различитих резултата. Анализа се може поделити на три кључна аспекта: апсолутне перформансе, ефикасност скалирања и утицај додатног оптерећења.

=== Апсолутне перформансе

Највећа разлика између две имплементације је у основној брзини извршавања. Као што је показано у експерименту јаког скалирања, секвенцијална _Rust_ имплементација је завршила задатак за просечно 28.08 секунди. У идентичним условима, секвенцијалној _Python_ имплементацији је било потребно 533.13 секунди. То значи да је _Rust_ верзија приближно 19 пута бржа.

Ова разлика је директна последица природе два језика. Главни део рачунарског рада у PoW алгоритму је константно израчунавање хешева. Као компајлирани језик, _Rust_ преводи ове операције у високо оптимизован машински код који се извршава на самом процесору. _Python_ као интерпретирани језик сваку операцију прослеђује кроз неколико слојева апстракције унутар свог интерпретера пре него што се она изврши. У задатку који се састоји од милиона понављања једне те исте криптографске операције, ово додатно оптерећење _Python_ интерпретера долази до изражаја и даје значајно лошије перформансе.

=== Ефикасност скалирања

Док апсолутне перформансе показују колико је један језик бржи од другог у основи, ефикасност скалирања показује колико добро сваки од њих користи додатне процесорске ресурсе.

У експерименту јаког скалирања, обе имплементације су показале добро почетно скалирање. Међутим, док _Rust_ одржава високу ефикасност и при већем броју радника , _Python_ показује значајно бржи пад ефикасности.

Разлике постају још драстичније у експерименту слабог скалирања. _Rust_ показује благи пораст времена извршавања, што указује на добро, али не савршено скалирање. _Python_ не успева да одржи константно време извршавања.

=== Утицај модела паралелизације

Узрок овако различитог понашања у скалирању лежи у различитим моделима паралелизације које ова два језика користе.

 -   *_Rust_: Лаке нити и дељена меморија*
    Имплементација у _Rust_-у користи праве системске нити којима управља библиотека _`Rayon`_. Ове нити се извршавају унутар истог процеса и деле исти меморијски простор. Комуникација и синхронизација међу њима се одвијају преко изузетно ефикасних, хардверски убрзаних атомских операција. _`Rayon`_ такође имплементира _"work-stealing"_ алгоритам, где незапослене нити краду посао од оптерећених, што обезбеђује оптималну искоришћеност свих језгара. Додатно оптерећење овог модела је минимално, што омогућава одлично скалирање.

 -   *_Python_: Тешки процеси и серијализација*
    Због GIL-а, Python за CPU-интензивне задатке мора да користи _`multiprocessing`_, који покреће потпуно одвојене процесе. Сваки процес има свој меморијски простор, а комуникација између њих захтева да се подаци серијализују у главном процесу, пошаљу преко оперативног система, а затим десеријализују у радничком процесу. Овај процес је рачунарски веома скуп и постаје уско грло како се повећава број радника и количина података који се размењују. Управо је ово оптерећење главни разлог зашто ефикасност _Python_ имплементације драстично опада, нарочито у експерименту слабог скалирања где се обрађује већа количина посла.

Док _Python_ нуди једноставност и брзину развоја, _Rust_ показује супериорност за развој високо перформансних, паралелних система. У контексту решавања проблема као што је _Proof-of-Work_ рударење, предности које нуди компајлирани програмски језик напредним моделом паралелизације су неоспорне.


== Анализа перформанси _Proof-of-Stake_ симулације

За разлику од _Proof-of-Work_, где је перформанса система директно везана за рачунарску снагу и брзину хеширања, _Proof-of-Stake_ систем је ограничен брзином валидације трансакција и мрежном комуникацијом. Због тога се на њега не могу применити класични експерименти скалирања на исти начин. Уместо мерења убрзања _"brute-force"_ претраге, кључне метрике постају _пропусност_ (енг. _throughput_) и време креирања блока.

У оквиру овог рада, извршена су мерења перформанси имплементиране PoS симулације у _Rust_-у.

=== Резултати мерења

Извршена су два сета мерења, један са 8 и један са 12 симулираних валидатора.

#figure(
  table(
    columns: 5,
    [ *Број валидатора*], [*Укупно блокова*], [*Укупно трансакција*], [*Пропусност (TPS)*], [*Просечно време по блоку (ms)*],
    [ 8 ], [ 20 ], [ 100 ], [ 1716.21 ], [ 2.91 ],
    [ 12 ], [ 30 ], [ 150 ], [ 1444.20 ], [ 3.46 ],
  ),
  caption: [Резултати перформанси за PoS симулацију]
)

Анализа резултата показује изузетно високе перформансе. У конфигурацији са 8 валидатора, систем је постигао пропусност од преко 1700 трансакција у секунди (TPS), док је просечно време потребно за валидацију и креирање једног блока било мање од 3 милисекунде. Са повећањем броја валидатора на 12, долази до благог пада пропусности и повећања времена по блоку, што је очекивано понашање због већег оптерећења система услед координације већег броја нити. Ипак, перформансе остају на веома високом нивоу.

Анализа статистике валидатора потврђује да механизам пондерисаног избора исправно функционише. Као што се види, иако случајност игра улогу, постоји јасна корелација где су валидатори са већим улогом (`stake`), попут валидатора 10 (улог 852), чешће бирани да предложе блок, док је валидатор са најмањим улогом (_ID_ 4, улог 323) био изабран нула пута.

#figure(
  table(
    columns: 3,
    [ *_ID_ Валидатора*], [*Улог (_stake_)*], [*Број избора*],
    [ 10 ], [ 852 ], [ 5 ],
    [ 3 ], [ 843 ], [ 4 ],
    [ 7 ], [ 541 ], [ 4 ],
    [ 2 ], [ 992 ], [ 3 ],
    [ 8 ], [ 832 ], [ 3 ],
    [ 6 ], [ 646 ], [ 3 ],
    [ 9 ], [ 747 ], [ 2 ],
    [ 11 ], [ 607 ], [ 2 ],
    [ 5 ], [ 443 ], [ 2 ],
    [ 0 ], [ 578 ], [ 1 ],
    [ 1 ], [ 635 ], [ 1 ],
    [ 4 ], [ 323 ], [ 0 ],
  ),
  caption: [Пример статистике избора валидатора у симулацији са 12 учесника]
)
=== Анализа PoW наспрам PoS

Директно поређење ових резултата са перформансама PoW система открива фундаменталне разлике у архитектури и ефикасности ова два приступа:

1.  *Брзина креирања блока:* У PoW систему, време креирања блока је намерно отежано и у експериментима се мерило у десетинама секунди. У PoS симулацији, исто време се мери у милисекундама. Ова разлика од неколико редова величине је највећа предност PoS система. Она произилази из чињенице да PoS елиминише потребу за рачунарски скупим и спорим процесом рударења.

2.  *Пропусност:* Због изузетно брзог креирања блокова, PoS систем може да обради значајно већи број трансакција у секунди. Док је PoW систем у овом раду имао ефективну пропусност мању од 1 TPS, PoS симулација је показала капацитет од преко 1400 TPS. Ово чини PoS далеко погоднијим за апликације које захтевају брзе и јефтине трансакције, као што су системи за плаћање или децентрализоване апликације високе фреквенције.

3.  *Потрошња ресурса:* Иако није директно мерена, разлика у потрошњи ресурса је очигледна. PoW систем је током рударења константно користио 100% свих доступних CPU језгара. Са друге стране, PoS систем користи ресурсе само у кратким интервалима током процеса валидације, док је већину времена у стању мировања. Ово потврђује теоријску претпоставку да је PoS значајно енергетски ефикаснији.

У закључку, иако је имплементирани PoS систем симулација, он јасно демонстрира огромне предности у перформансама у односу на _Proof-of-Work_. Елиминисањем _"brute-force"_ рударења, PoS омогућава креирање блокчејн система који су знатно бржи, ефикаснији и скалабилнији, што отвара врата за много шири спектар практичних примена.